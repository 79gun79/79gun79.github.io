---
title: "[TypeScript] 클래스"
date: 2025-04-11 18:56:13 +0900
categories: [프로그래머스 데브코스, 타입스크립트]
tags: [study, programmers, typescript, class]
---

## 클래스  

- **<span class="yellowpen">자바스크립트</span>**  에서 클래스를 사용했듯이, **<span class="bluepen">타입스크립트</span>**에서도 사용 가능하다.  

### TS 클래스의 타입 선언   

- **<span class="bluepen">타입스크립트</span>**에서는 타입을 명시해야한다는 점에서 구분.    

<div markdown="1" class="bbox">

#### **<span class="yellowpen">자바스크립트</span>**   

```ts  
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const person = new Person("jaegeon", 26);
console.log(person);
```    
</div>


<div markdown="1" class="bbox">  

#### **<span class="bluepen">타입스크립트</span>**   

```ts   
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
const person = new Person("jaegeon", 26);
console.log(person);
```   
</div>  

### TS 클래스의 접근 제어자  

- **<span class="bluepen">타입스크립트</span>**에서는 속성이나 메서드에 대한 접근을 제한하도록 키워드를 사용.   
    
    
    | 키워드                                           | 설명                              |
    | ------------------------------------------------ | --------------------------------- |
    | **<span class="purplepen">public</span>** (기본) | 어디서든 접근 가능                |
    | **<span class="purplepen">protected</span>**     | 클래스 및 자식 클래스에 접근 가능 |
    | **<span class="purplepen">private</span>**       | 클래스 내부에만 접근 가능         |
  
- **<span class="purplepen">private</span>**의 문제점  
    
    분명 클래스 내부에서만 사용할 수 있는데,   
    생성된 객체를 호출할 때, <span class="redpen">속성(멤버)이 나타나는 문제</span>    
    
    ```ts
    class Person {
      private name: string;
      private age: number;
    
      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }
    const person = new Person("jaegeon", 26);
    console.log(person); // 멤버가 모두 출력됨
    ```   
    <img width="314" height="42" alt="Image" src="https://github.com/user-attachments/assets/24e81416-7bd9-4ed1-b2ed-8937e6d57b9d" />    
    
- **`#` 키워드** (ES2022 이후 지원)  
    
    **<span class="purplepen">private</span>**와 기능은 동일,    
    생성된 객체를 호출할 때, <span class="bluepen">속성 또한 나타나지 않는다!</span>    
    
    ```ts
    class Person {
      #name: string;
      #age: number;
    
      constructor(name: string, age: number) {
        this.#name = name;
        this.#age = age;
      }
    }
    const person = new Person("jaegeon", 26);
    console.log(person);
    ```   
    <img width="133" height="35" alt="Image" src="https://github.com/user-attachments/assets/40e2b293-cf8e-4c3b-9cfd-c0ea097f7aa9" />    
    
### TS 클래스의 **<span class="purplepen">readonly</span>** 키워드  

- **<span class="bluepen">타입스크립트</span>**에서는 <span class="red2pen">한 번 할당된 이후, 변경할 수 없는 속성</span>을 만들 수 있음   
- 읽기 전용 필드를 정의함.  
     
    ```ts  
    class Person {
      readonly name: string;  // 읽기 전용
      age: number;
    
      constructor(name: string, age: number) {
        this.name = name;  // ✅ 초기 할당 가능
        this.age = age;
      }
    }
    
    const person = new Person("jaegeon", 26);
    console.log(person.name);       // jaegeon
    
    person.name = "hong";           // ❌ 에러(수정 불가)
    ```    
    
### TS 클래스의 추상 클래스  

- 클래스의 구조를 추상적으로 미리 정의해 놓은 클래스  
- **`abstract`** 키워드를 사용하여 추상 클래스를 생성.  
  ⇒ 각각의 클래스와 속성 앞에 제시.  
- **`extends`** 키워드를 사용하여 **상속** 받아서 클래스를 구현함.  
- `super()` 를 사용하여 추상 클래스의 구조를 가져옴.  
- 구현을 위해 접근제어자를 추가하기도 함.  
    
    ```ts   
    abstract class Shape {
      abstract area(): number;
      abstract radius: number;
    }
    class Circle extends Shape {
      constructor(public radius: number) {
        super();
      }
      area() {
        return Math.PI * this.radius;
      }
    }
    ```   
- 클래스는 <span class="yellow2pen">**추상 클래스** 하나만 상속</span> 가능하다.(<span class="redpen">다중 상속 X</span>)  

### TS 클래스의 인터페이스와 타입 상속  

- 클래스는 **타입 별칭**과 **인터페이스**를 **상속**해서 사용가능하다.   
- 추상 클래스와 다르게, <span class="bluepen">다중 상속이 가능</span>하다.   
- **`implements`** 키워드를 사용하여 **상속** 받아서 사용.    

### TS 클래스의 제네릭  

- 앞서 배운 **제네릭**을 클래스에서도 사용 가능하다.  
- 클래스명 옆에 **제네릭**을 제시해서 사용한다.  
    
    ```ts  
    class Box<T> {
      value: T;
      constructor(value: T) {
        this.value = value;
      }
      getValue() {
        return this.value;
      }
    } 
    
    const stringBox: Box<string> = new Box<string>("abc");
    console.log(stringBox.getValue());
    ```  

<br>

---

## 클래스 상속

- 클래스끼리 상속도 가능하다.
- 역시, **`extends`** 키워드를 사용하여 **상속** 받는다.
- `super()` 를 사용하여, **자식 클래스**는 <span class="yellow2pen">부모 클래스의 생성자 호출</span>이 가능하다.    
- **자식 클래스**는 부모 클래스의 속성과 메서드 모두를 사용할 수 있다.     
  (<span class="redpen">접근제어자에 의해 막히지만 않는다면</span>)  
- 예시  
    
    ```ts  
    class Employee {
      name: string;
      constructor(name: string) {
        this.name = name;
      }
    
      getSalary() {
        console.log("Salary!");
      }
    }
    
    class Manager extends Employee {
      role: string;
      constructor(name: string, role: string) {
        super(name);
        this.role = role;
      }
      getManager() {
        console.log(`${this.name}: ${this.role}`);
      }
    }
    
    const employee = new Employee("John");
    employee.getSalary();
    const manager = new Manager("Mike", "admin");
    manager.getSalary();
    manager.getManager();
    ```  
    
### 부모 클래스의 접근 제어  

- 앞서 배운 **<span class="purplepen">접근 제어자</span>**를 활용하면,   
  특정 속성과 메서드에 대해 **자식 클래스**의 접근을 막을 수 있다.  
- **<span class="purplepen">protected</span>**의 키워드     
  해당 키워드를 사용하여, <span class="bluepen">자식 클래스의 접근은 가능</span>하면서,    
  외부로부터 안전한 속성과 메서드를 가질 수 있다.  