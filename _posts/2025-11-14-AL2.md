---
title: "[Algorithm] 시간복잡도"
date: 2025-11-14 15:11:27 +0900
categories: [알고리즘, 풀이방식]
tags: [algorithm]
---

<img width="1271" height="713" alt="알고리즘" src="https://github.com/user-attachments/assets/944edd6f-9b79-4ab8-b0c4-e77dcc872468" />

## **시간 복잡도 Time Complexity**

- <span class="yellow2pen">**입력 값**과 **연산 수행 시간**의 상관관계를 나타내는 척도</span>   
- 알고리즘을 풀 때, 다음과 같이 <span class="redpen">시간 초과</span>가 나는 경우가 본 적이 있을 것이다.   
    
    <img width="1065" height="533" alt="Image" src="https://github.com/user-attachments/assets/10c26db9-ecdd-4e17-8d16-9a708edfdf45" />   

- 이와 같이, 알고리즘은 **<span class="bluepen">효율성</span>**도 중요한 척도이기 때문에, 계산하는 방법을 알아야한다!     

<br> 

### **시간 복잡도 표기법, 빅오 표기법(Big-O)**

- 시간 복잡도를 나타내기 위한 기법으로 <span class="yellow2pen">3가지가 존재</span>한다.   
    
    <img width="746" height="380" alt="Image" src="https://github.com/user-attachments/assets/4af5f465-37a6-4b3a-afed-93ecf4015c33" />  
    

⇒ 따라서, 우리는 항상 **빅오 표기법**을 활용한 시간 복잡도 계산을 알아야한다!  

<br>

### **빅오 표기법의 시간 복잡도 단계**

- **빅오 표기**는 <span class="redpen">입력된 N의 크기</span>에 따라 <span class="yellow2pen">실행되는 연산 횟수</span>로 **시간 복잡도**를 표현한다.   
- 시간복잡도의 단계는 아래와 같이 크게 나눠볼 수 있다.   
    
    <img width="1206" height="364" alt="Image" src="https://github.com/user-attachments/assets/9e8e146c-727f-4b77-b460-8ab8bf2f7e10" />        

⇒ 여기서, 우리는 **2차 시간**을 <span class="yellow2pen">더 빠른 시간으로 줄일 수 없는가</span>를 생각해봐야한다!   

<br>
<br>

---

## **시간복잡도 단계**

- 앞서 봤던, 시간 복잡도 단계별로 예제를 제시해보겠다.   
- **입력**은 항상 **<span class="yellow2pen">N(또는 M)</span>**으로 주어진다고 생각하겠다.   
    
    <img width="1206" height="364" alt="Image" src="https://github.com/user-attachments/assets/9e8e146c-727f-4b77-b460-8ab8bf2f7e10" />          
    
> 💡 단계를 평가하는 기준은 항상 **N**이 <span class="yellow2pen">1부터 늘어나는 반복 횟수</span>임을 알아야 한다!     

<br>

### 1️⃣ **O(1) 상수 시간**

```java   
int sum = (N + 1) * N / 2;
```   

- 위와 같은 예시는 흔히, <span class="red2pen">2차 시간이라 오해</span>할 수 있다!      
- 실제 연산 횟수를 확인해보면, 다음과 같이 4번이다.    
    
    <img width="716" height="265" alt="Image" src="https://github.com/user-attachments/assets/6afaddba-f94b-4618-b51b-578fdc45e49b" />        

⇒ 따라서 총 연산 횟수 <span class="yellow2pen">**4 = O(1)**에 가까우므로 상수시간</span>이 된다.   

- 왜 상수 시간이냐고 하면은 <span class="redpen">**N**과 관계 없는 연산</span>이기 때문이다.    
    
    <img width="781" height="416" alt="Image" src="https://github.com/user-attachments/assets/4a05c319-62c9-4d29-8c8c-98393157d713" />        

> 결론으로! <span class="redpen">N의 영향을 받지 않는 사칙 연산을 제외</span>한 <span class="yellow2pen">대입 연산이 1회</span> 일어나므로,      
> 위와 같은 예제는 **상수 시간**으로 평가하면 된다.    

<br>

### 2️⃣ **O(log n) 로그 시간**

```java
int i = 1;
while (i < N) { 
		System.out.println(i); 
		i = i * 2; 
}
```

- 앞서 상수 시간에서, <span class="redpen">사칙 연산은 N과 관계 없는 연산임</span>을 알았다면 다음과 같이 평가할 수 있다.    
    
    <img width="976" height="307" alt="Image" src="https://github.com/user-attachments/assets/3ec13703-8dbd-4666-8123-8cbad44fc140" />   
        
- 근데 <span class="bluepen">N과 관계 된 i</span>가 거듭제곱으로 커지고 있으므로, 다음과 같은 평가 가능하다.   
    
    <img width="669" height="552" alt="Image" src="https://github.com/user-attachments/assets/21c68b0d-c6fa-47d1-af9a-34313d6a82e3" />    

> 결론으로! N이 1부터 하나씩 차례로 반복하는 것이 아닌,    
> <span class="bluepen">거듭제곱으로 건너 뛰면서 반복</span>하므로, **로그 시간**으로 평가할 수 있다!  

> 💡 대표 예시: **<span class="bluepen">이진 탐색 알고리즘</span>**  
   
<br>

### 3️⃣ **O(n) 선형 시간**

```java
int sum = 0;
for (let i = 0; i <= N; i++) {
		System.out.println(i);
		sum += i;
}
```

- 이 예제처럼, <span class="yellow2pen">i가 0부터 하나씩 커지면서 N까지 반복</span>하면 **선형 시간**으로 평가할 수 있다.   
    
    <img width="1066" height="506" alt="Image" src="https://github.com/user-attachments/assets/0ccb30b0-8667-4adc-a956-ca1e2aabf1a6" />        

> 결론으로, 2N, 3N, 4N, … 씩 나와도 <span class="redpen">N 앞의 상수 배는 빅오의 영향을 받지 않는다.</span>        
> 따라서, 2N, 3N, 4N, …  모두 **선형 시간**으로 평가 가능하다.     
  
> 💡 대표 예시: **<span class="bluepen">DFS 알고리즘</span>**, **<span class="bluepen">DP(Dynamic Programming) 알고리즘</span>**

<br>   

### 4️⃣ **O(n log n) 선형 로그 시간**

```java   
int[] intArr = new int[] {1,3,2,5,4};                     
Arrays.sort(in tArr);            
```    

- **선형 로그 시간**은 <span class="yellow2pen">정렬</span>이 보통이 이에 해당한다.
- 정렬은 병합 정렬, 퀵 정렬, 힙 정렬 등.. 다양한 방법이 존재하지만,     
  <span class="yellow2pen">정렬에서 가장 빠른 시간 복잡도</span>는 **NlogN**으로 평가한다.     
    
    <img width="1301" height="542" alt="Image" src="https://github.com/user-attachments/assets/86cb97d1-00c2-44e2-85b4-a8203c443d02" />      

> 결론으로, <span class="yellow2pen">길이가 N인 배열을 정렬할 때</span>의 가장 빠른 횟수는 **NlogN**이므로      
> 해당 연산 횟수를 **선형 로그 시간**으로 평가하도록 한다.      

> 💡 대표 예시: **<span class="bluepen">정렬 알고리즘</span>**

<br>   

### 5️⃣ **O(n^2) 2차 시간**

```java
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        System.out.println(i + ", " + j);
    }
}
```

- 결국, 가장 많이 나오는 케이스가 위와 같은 경우이다.    
- 위와 같이 N이 주어졌을 때, <span class="yellow2pen">각 원소를 다른 모든 원소랑 비교하는 경우</span>가 **2차 시간**에 해당한다.   

> 결국 코딩테스트의 시간 복잡도를 줄이는 방법은    
> 위와 같은 예제를 <span class="redpen">다른 알고리즘이나 방법으로 줄여나가는 과정</span>이다!        

> 💡 대표 예시: **<span class="bluepen">완전 탐색</span>**     

<br>
<br>

---

## **시간복잡도 계산**

### **백준 문제 시간 제한**

- 백준 문제는 다음과 같이 시간 제한이 존재한다.   
    
    <img width="786" height="207" alt="Image" src="https://github.com/user-attachments/assets/af4af970-3495-4453-bcd0-7a29c39cfeb4" />
       
- 여기서 말하는 **1초**는 <span class="yellow2pen">10,000,000번(1억번)의 연산 횟수</span>를 의미한다!     
- 따라서 테스트에 통과하려면, 앞서 배운 방법을 토대로 <span class="bluepen">연산 횟수를 계산</span>하여    
  초과하지 않는지를 계산하면 된다.   

<br>

### **연산 횟수 계산**

- 자 그렇다면, 문제별 연산횟수를 어떻게 계산하는지를 단계별로 알아보자.

<div class="bbox" mardown="1">

  <p style="margin-top: 15px">1. <b>시간 제한</b>과 <b>입력 크기(예: <span clas="redpen">N</span>) 제한</b> 확인!</p>
    
  <img width="899" height="216" alt="Image" src="https://github.com/user-attachments/assets/148e5345-2e49-4caa-bd05-c9290f343f46" />     

  <img width="883" height="300" alt="Image" src="https://github.com/user-attachments/assets/f13fb344-93d7-4d4a-8106-7778fbf94bab" />   
    
</div>

<div class="bbox" mardown="1">

  <p style="margin-top: 15px">2. 내가 짠 코드의 시간 복잡도 계산</p>   
  
  <img width="969" height="730" alt="Image" src="https://github.com/user-attachments/assets/a016acbc-50f9-4a84-8aba-f5fa9a33b3c1" />     
       
</div>

<div class="bbox" mardown="1">

  <p style="margin-top: 15px">3. 내가 짠 코드의 **<span class="bluepen">효율성</span>** 판단</p>     

  <img width="689" height="286" alt="Image" src="https://github.com/user-attachments/assets/991cb193-527d-4d04-a760-022dc396325e" />

</div>

<div class="bbox" mardown="1">

  <p style="margin-top: 15px">4. 제출 확인</p>     
    
  <img width="999" height="79" alt="Image" src="https://github.com/user-attachments/assets/4c8a1ed9-35ea-4351-a5b4-d142a529caed" />     

</div>

<br>
<br>

---

### **총정리**

- 시간 복잡도의 핵심은 **<span class="yellow2pen">시간 제한</span>**이 얼마인지와 <span class="yellow2pen">**입력 크기**가 어느 정도로 큰지</span>를 확인하는 것이다.  
- **입력 크기**는 다음과 같이 <span class="bluepen">~로 주어진다에 문구</span>에 유의하며 확인해보록 하자!   
    
    <img width="689" height="96" alt="Image" src="https://github.com/user-attachments/assets/b0f36bfb-0afb-4190-9085-89c987080c98" />  

    <img width="348" height="156" alt="Image" src="https://github.com/user-attachments/assets/a64832d1-4616-4ff2-9365-dbf8a0941957" />  

    <img width="410" height="88" alt="Image" src="https://github.com/user-attachments/assets/3144372d-561b-4f0f-bf0b-9dd09a6089c3" />   

<br>

---

##### ✨ 출처   

[Blog, [algorithm] 시간복잡도란? 시간복잡도 계산하는법 ( O(1), O(n), O(log n))](https://joyhong-91.tistory.com/12#log2)     
{: .small}     

---


