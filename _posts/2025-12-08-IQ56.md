---
title: "[Tech] 프로세스 & 스레드 심화"
date: 2025-12-08 14:12:26 +0900
categories: [CS, CS-기술면접]
tags: [study, cs, process, thread]
---

<img width="1271" height="713" alt="면접cs" src="https://github.com/user-attachments/assets/56215fe2-e16a-4ebd-b44c-8c26450b1722" />

전에, 프로세스와 스레드를 다룬 내용의 글을 쓴 적이 있었다.

- [GunBlog, 프로세스와 스레드의 차이는?!](https://79gun79.github.io/posts/IQ28/#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94)        

- [GunBlog, 멀티 프로세스와 멀티 스레드란?!](https://79gun79.github.io/posts/IQ29/#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%9E%80)      

하지만, 내용이 부실함을 느꼈고, 심화적인 내용을 바탕으로 글을 정리하고자 한다.

<br>

---

## **프로세스 컴파일 과정**

<img width="1266" height="270" alt="Image" src="https://github.com/user-attachments/assets/d45e64af-f348-40f6-b69c-e6a6c5de9ca4" />    

**프로세스 컴파일**은 크게 4가지 과정을 거쳐서 일어난다.

**1. 전처리**(Pre-Processing)
    
  - 소스 코드 파일을 <span class="yellow2pen">전처리 된 소스 파일로 변환</span>하는 과정을 의미한다.     
  - 소스 **코드에서 주석을 전부 제거**하고, **헤더 파일을 병합**한다. 
  - 이후, **매크로를 치환**하고 적용한다.     
  
**2. 컴파일**(Compile)
    
  - 전처리 된 소스 파일을 <span class="yellow2pen">어셈블리어 파일로 변환</span>하는 과정을 의미한다.     
  - 이 때, **오류 처리**와 **코드 최적화 작업**이 일어난다.     
  
**3. 어셈블리**(Assembly)
    
  - 어셈블리어로 작성된 소스 코드를 <span class="yellow2pen">오브젝트 파일로 변환</span>하는 과정을 의미한다.     
  - 여기서 오브젝트 파일은 사람이 알아볼 수 없는 **기계어 코드로 변환**된 파일이다.     
  
**4. 링킹**(Linking)
    
  - 여러 오브젝트 파일들을 묶어 <span class="yellow2pen">실행 파일을 만드는</span> 과정을 의미한다.     

> 이렇게 4가지 과정을 거쳐, CPU가 이해할 수 있도록 번역하는 작업을 거친다.  

<br>

---

## **프로세스 상태 값** 

<img width="1175" height="404" alt="Image" src="https://github.com/user-attachments/assets/928077c4-d0f3-4448-8b81-3955beb585b9" />

프로세스는 다음과 같이 **5가지의 상태 값**을 가지며, 실행되면서 변한다.   

- **<span class="bluepen">new</span>**, 생성 상태    
  프로세스가 생성된 상태를 의미한다.     

- **<span class="bluepen">running</span>**, 실행 상태      
  CPU 소유권과 메모리를 할당받고, 명령어를 수행 중인 상태를 의미한다.  

- **<span class="bluepen">ready</span>**, 준비 상태       
  프로세스가 CPU 스케줄러부터 CPU 소유권이 넘어오기를 기다리는 상태를 의미한다.     
   
- **<span class="bluepen">waiting</span>**, 대기 상태      
  인터럽트에 의해, 프로세스가 어떤 이벤트가 일어나기를 기다리는 상태를 의미한다.  

- **<span class="bluepen">terminated</span>**, 종료 상태     
  프로세스가 메모리와 CPU 소유권을 모두 놓고, 실행이 종료된 상태를 의미한다.    

> 특히, **실행 상태**에서 **바뀔 수 있는 상태가 3가지**며, 변환하는 작업을 생각하며 보자.

<br>

---

## **프로세스의 구조**     

<img width="376" height="657" alt="Image" src="https://github.com/user-attachments/assets/aa2cbda7-7977-426a-a14b-a8711b9cc245" />

프로세스는 다음과 같이 **4가지의 구조**로 나뉘며, 할당된다.     

- **<span class="bluepen">Stack</span>**       
  - 함수 매개변수, 반환 주소, 지역 변수가 저장된다.   
  - **컴파일 때, 크기가 결정**되고 **동적인 메모리 특징**을 갖는다.        
  - 함수 호출의 임시 데이터 저장 장소로 동작한다.  

- **<span class="bluepen">Heap</span>**       
  - 실행 중, **동적으로 할당**되는 메모리이다.   
  - 가변 크기의 데이터를 저장할 때 활용된다.  
  - `new()`, `malloc()`, `calloc()` 등의 함수를 사용하여 할당 시, 해당 영역에서 메로리가 할당된다.    

- **<span class="bluepen">Data 영역</span>**       
  - 전역변수, 정적변수가 저장된다.  

- **<span class="bluepen">Code 영역</span>**       
  - 프로그램의 소스 코드가 저장된다.      

<br>

---

## **PCB**, 프로세스 제어 블록

- **P**rocess **C**ontrol **B**lock     
- 운영체제에서, <span class="yellow2pen">프로세스에 대한 메타데이터를 저장한 **데이터**</span>를 의미한다.    
- 프로세스마다 존재하며, 일반 사용자가 접근하지 못하도록 관리된다.  

### **PCB의 구조**

<img width="313" height="640" alt="Image" src="https://github.com/user-attachments/assets/5a4e3b34-3fb1-4174-b0ac-d5e481b4a7bf" />   

- **프로세스 상태**: 프로세스의 현재 상태를 담는다. 
- **프로세스 식별자**: 프로세스를 유일하게 식별할 수 있는 ID   
- **프로그램 카운터**(PC): <span class="yellow2pen">다음에 수행할 명령어 주소</span>     
- **CPU 레지스터**: 레지스터의 값이 담긴다.
- 오픈파일 목록
- 메모리 제한
- 이 외에도, CPU 스케줄링 정보, 메모리 관리 정보, I/O 상태 정보가 담긴다.   

<br>

---

### **싱글 스레드와 멀티 스레드**   

<img width="895" height="620" alt="Image" src="https://github.com/user-attachments/assets/d15cff95-99dc-4d09-a769-dfe765c7ea41" />

위와 같이, **싱글 스레드**와 **멀티 스레드**는 구분된다. 각각의 장단점에 대해 알아보자.   

### **싱글 스레드**

- 하나의 프로세스에 하나의 스레드가 있는 구조  
- <span class="yellow2pen">하나의 레지스터와 스택</span>으로 구성되어 있다.   

**싱글 스레드의 <span class="bluepen">장점</span>**    
- 작업 전환(Context Switching)과 자원 접근에 대한 것을 신경쓰지 않아도 된다.  
- 비교적 적은 비용으로 구성 가능하다.   

**싱글 스레드의 <span class="redpen">단점</span>**     
- 여러 개의 CPU를 활용하지 못한다.  
- 비교적 적은 비용으로 구성 가능하다.    
- 순차적으로 실행해서, 많은 작업의 처리에서는 비효율적이다.   

### **멀티 스레드**

- 하나의 프로세스에 여러 개의 스레드가 있는 구조  
- <span class="yellow2pen">각각 고유의 레지스터와 스택</span>으로 구성되어 있다.     
- 프로세스 내에서는 <span class="yellow2pen">자원을 공유하여, 중복을 최소화</span>한다.    

**멀티 스레드의 <span class="bluepen">장점</span>**    
- 스레드를 생성하는 과정이 비교적 빠르다.  
- 자원과 상태를 공유하여, 효율적인 운영이 가능하다.  

**멀티 스레드의 <span class="redpen">단점</span>**     
- 비교적 많은 비용이 필요하다.
- 작업 전환과 스레드 스케줄링을 살펴야 한다.  

<br>

---

##### ✨ 출처   

[prepare_frontend_interview](https://github.com/junh0328/prepare_frontend_interview)        
[Blog, 프로세스의 컴파일](https://june-17.tistory.com/343)       
<span class="bluepen">Abraham Silberschatz, 운영체제</span>        
{: .small}     

---