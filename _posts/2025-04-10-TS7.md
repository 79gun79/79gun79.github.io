---
title: "[TypeScript] 인터페이스"
date: 2025-04-10 19:27:13 +0900
categories: [프로그래머스 데브코스, 타입스크립트]
tags: [study, programmers, typescript, interface]
---

<img width="1271" height="713" alt="데브타스" src="https://github.com/user-attachments/assets/9326156f-9ea0-4a50-934b-2c7097cfacea" />

## **인터페이스**

- 앞서 배운 **타입 별칭**의 개념을 비교하며 살펴본다.  
- **타입 별칭**으로 지정할 수 있는 <span class="orangepen">객체</span> → **인터페이스**로도 설정 가능  
- 따라서, **<span class="orangepen">객체 타입</span>**만이 **인터페이스**로 설정 가능 (<span class="redpen">원시 타입 불가!</span>)   
- **`interface`** 키워드를 사용하여, 지정   
- 예시  
    
    ```ts   
    // 객체 타입을 지정 시 사용 (나만의 객체 타입)
    interface User {
      name: string;
      age: number;
    }
    
    const user1: User = {
      name: "jaegeon",
      age: 20,
    };
    -------------------------------------------
    interface User {
      name: string;
      age: number;
      greet(): void;
    }
    const user1: User = {
      name: "jaegeon",
      age: 26,
      greet() {
        console.log(`${this.name}, ${this.age}`);
      },
    };
    user1.greet();
    ```  
    
### 인터페이스 특징  

1. **타입 별칭**과 달리, 상세 스펙이 보이지 않음.  
    
    <img width="325" height="153" alt="Image" src="https://github.com/user-attachments/assets/a052cfcc-b61a-43cb-a04a-758ac2f46460" />  
    
2. **타입 별칭**과 달리, 인터페이스명 <span class="bluepen">중복 가능</span>.  
   ⇒ <span class="yellow2pen">이름이 같다면, 자동으로 합쳐줌</span>. (**선언 병합**)     
    
    <img width="201" height="182" alt="Image" src="https://github.com/user-attachments/assets/61c28d69-0a12-4c7d-9ba5-1107acd9a01d" />  
    
    **<span class="redpen">→ 주의사항</span>**: 인터페이스 내의 <span class="redpen">각 속성의 타입이 달라서는 안된다</span>!   
    
    <img width="262" height="189" alt="Image" src="https://github.com/user-attachments/assets/90fb24ca-6ab5-48f0-8f96-7724af99ec35" />  
    

### 인터페이스 - 함수  

- 함수를 인터페이스로 지정하면 다음과 같다.  
    
    ```ts  
    // 함수 별칭의 경우
    type SumFunc = (n1: number, n2: number) => number;
    
    // 인터페이스로 함수 정의
    interface SumFuncInterface {
      (n1: number, n2: number): number;
    }
    
    const sum: SumFuncInterface = (n1, n2) => n1 + n2;
    ```  
    
**<span class="redpen">→ 주의사항</span>**: 인터페이스로 지정한 **<span class="bluepen">함수</span>**에는 **옵셔널 파라미터 `?`**를 지정할 수 없다.  

- 함수를 지정 시에, **`name`**과 같은 함수에 원래 존재하는 속성을 사용 가능!
    
    ```ts  
    // 함수 별칭의 경우
    type SumFunc = (n1: number, n2: number) => number;
    
    // 인터페이스로 함수 정의
    interface SumFuncInterface {
    	name: string;
      (n1: number, n2: number): number;
    }
    
    const sum: SumFuncInterface = (n1, n2) => n1 + n2;
    ```  
    
- 함수에 원래 존재하는 속성들 (**`caller`**는 안됨!)  
    
    <img width="272" height="187" alt="Image" src="https://github.com/user-attachments/assets/55694169-45e7-4806-89bd-33b967d0d09f" />  
    

### 인터페이스 상속  

- 자바스크립트(타입스크립트)에서 인터페이스를 **상속**할 수 있음  
- **`extends`** 키워드를 사용하여, 상속을 표현  
- 문법적으로도, **인터페이스 상속** > **타입 별칭 &** 용이.  
- 공통으로 들어가는 부분을 각각의 인터페이스 사용할 때 용이.  
- 예시
    
    ```ts  
    interface Animal {
      name: string;
    }
    
    interface Dog extends Animal {
      bark(): void; // 왈왈
    }
    const dog: Dog = {
      name: "퍼피",
      bark() {
        console.log("왈왈");
      },
    };
    
    interface Cat extends Animal {
      bark(): void; // 냐옹
    }
    const cat: Cat = {
      name: "냥이",
      bark() {
        console.log("냐옹");
      },
    };
    ```  
    
- **다중 상속**도 컴마로 구분하여 <span class="bluepen">가능</span>하다!  
    
    ```ts  
    interface A {
      a: string;
    }
    interface B {
      b: number;
    }
    interface C extends A, B {
      c: boolean;
    }
    const cValue: C = {
      a: "a",
      b: 121,
      c: true,
    };
    ```  
    
- **타입 별칭**과 인터섹션 파라미터 **`&`**로도 유사하게 사용 가능!  
    
    ```ts  
    type A = {
      a: string;
    };
    type B = {
      b: number;
    };
    type C = A &
      B & {
        c: boolean;
      };
    const cValue: C = {
      a: "a",
      b: 121,
      c: true,
    };
    ```  
    
<br>

---

## **인덱스 시그니처**

- 다음 코드는 **옵셔널 파라미터 `?`**를 사용하지 않으면 <span class="redpen">속성 삭제 불가</span>    
  이외에, <span class="redpen">속성 추가와 수정도 불가</span>   
    
    ```ts  
    const obj: {
      name: string;
      age?: number;
    } = {
      name: "jaegeon",
      age: 26,
    };
    
    obj.gender = "male";
    delete obj.age;
    ```  
    
### 인덱스 시그니처  

- 범용적인 타입 지정 방식  
- 앞선 문제의 해결책으로 **인덱스 시그니처**를 사용.  
    
    ```ts  
    const obj: {
      [key: string]: string | number;
    } = {
      name: "jaegeon",
      age: 26,
    };
    
    obj.gender = "male";
    delete obj.age;
    ```  
    
- 객체의 속성을 자유롭게 <span class="bluepen">추가하거나 변경 가능</span>!  
- 단, <span class="redpen">명확한 타입 명시는 불가</span>!  
    
    <img width="536" height="72" alt="Image" src="https://github.com/user-attachments/assets/2b6c695a-4096-45d5-bd3e-07a7c10f1297" />   
  
- 따라서, 섞어서 사용하면 해당 문제를 해결할 수 있다.  
    
    ```ts  
    const obj: {
      name: string;
      age: number;
      [key: string]: string | number;
    } = {
      name: "jaegeon",
      age: 26,
    };
    
    const name1 = obj.name;
    name1.toUpperCase();
    ```  
    
<div markdown="1" class="bbox">

### [<span class="redpen">참고</span>] 헝가리안 표기법  

- 다음과 같이, 식별자의 타입이 다르나, <span class="redpen">이름이 같아서 문제 발생</span>  
    
    <img width="179" height="63" alt="Image" src="https://github.com/user-attachments/assets/37affddc-6baf-4c46-ad62-fb117e777ed6" />  
    
- 따라서, 헝가리 출신 개발자가 다음과 같이, 식별자 작성법 제시.  
  타입을 밝혀서 이름을 짓는 **헝가리안 표기법**  
    
    `number`: num → nNum  
    
    `string`: name → strName  
    
    `type`: User→ TUser  
    
    `interface`: User→ IUser  
    
    → But, 오늘날에는 <span class="redpen">위와 같은 방법 권장 X</span>    
    
- 이유: 식별자의 <span class="bluepen">타입의 변동 가능성</span>이 있음 → <span class="red2pen">잘못된 정보 제공 우려</span>    

→ 따라서, 오늘날에는 이름을 의미있게 지어주는게 추세이다.  

</div>

<br>

---

## **구조적 타이핑**  

- **<span class="bluepen">타입스크립트</span>**는 이름으로 구분하는 것이 아닌, 내부 구조로 구분함.  
- 이름이 달라도 구조가 같다면, 상호 호환이 됨.  
    
    ```ts  
    type Car = {
      name: string;
      speed: number;
    };
    type Vehicle = {
      name: string;
      speed: number;
    };
    
    let car: Car = { name: "MBW", speed: 100 };
    let vehicle: Vehicle = { name: "HONDA", speed: 200 };
    
    function printValue(obj: Car) {
      console.log(`${obj.name}, ${obj.speed}`);
    }
    
    printValue(vehicle);
    ```  
    
    위와 같이, 이름이 달라도 내부 구조가 같아. 다른 타입의 이름을 사용해도 무방.  
    

### 많은 속성과 적은 속성  

- 다음과 같이, `name` 속성이 포함된 두 객체에서  
  **<span class="graypen">더 많은 속성을 포함한 객체</span>**가 적은 속성을 포함한 객체로 할당될 수 있음!   
    
    ```ts  
    type Car = {
      name: string;
      speed: number;
    };
    type Vehicle = {
      name: string;
    };
    
    let car: Car = { name: "MBW", speed: 100 };
    let vehicle: Vehicle = { name: "HONDA" };
    
    vehicle = car; // 많은 속성이 적은 속성의 객체로 할당 가능
    console.log(vehicle);
    console.log(vehicle.speed); 
    // 담겼어도, speed 속성은 Vehicle에 없으므로 출력 불가
    ```  
    

<div markdown="1" class="bbox">

### ✏️ 총정리  

- 단순한 객체의 구조 정의 → **인터페이스** 
- 유니언, 튜플, 기본 타입, 함수 → **타입 별칭**  
- API 응답 값 → **타입 별칭**  
- 서로가 서로의 재료가 될 수 있음.   
      
    | 차이점         | **타입 별칭**                                                                | **인터페이스**                                                                    |
    | -------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
    | 선언하는 문법  | <span class="bluepen">type</span> **<span class="greenpen">Type</span>** = … | <span class="bluepen">interface</span> **<span class="greenpen">Type</span>** {…} |
    | 정의 가능 범위 | 모든 타입                                                                    | 객체 타입만                                                                       |
    | 추가 기능      | -                                                                            | 선언 병합, extends 상속                                                           |
  
</div>