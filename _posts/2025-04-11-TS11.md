---
title: "[TypeScript] 유틸리티 타입"
date: 2025-04-11 19:33:13 +0900
categories: [프로그래머스 데브코스, 타입스크립트]
tags: [study, programmers, typescript, utility]
---

<img width="1271" height="713" alt="데브타스" src="https://github.com/user-attachments/assets/9326156f-9ea0-4a50-934b-2c7097cfacea" />

## 유틸리티 타입

- **<span class="bluepen">타입스크립트</span>**에서 어떤 목적을 달성하기 위한 기능을 구현한 커스텀 타입을 의미  

### Partial< **<span class="greenpen">T</span>** >

- 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성을 <span class="yellow2pen">선택적으로 만드는 유틸리티 타입</span>   
- 다음과 같이, 하나의 인터페이스에 존재하는 것을   
  <span class="redpen">따로 인터페이스로 구현해서 사용해야하는 번거로움</span> 존재.   
    
    ```ts  
    interface User {
      name: string;
      age: number;
    }
    interface GuestType1 {
      name: string;
    }
    
    interface GuestType2 {
      age: number;
    }
    
    const user1: User = {
      name: "jaegeon",
      age: 26,
    };
    const guest1: GuestType1 = {
      name: "jaegeon",
    };
    const guest2: GuestType2 = {
      age: 26,
    };
    ```  
    
- 따라서, **Partial< <span class="greenpen">T</span> >**를 사용하여, <span class="yellow2pen">인터페이스의 일부를 이용</span>할 수 있도록 한다.   
    
    ```ts   
    interface User {
      name: string;
      age: number;
    }
    
    const user1: User = {
      name: "jaegeon",
      age: 26,
    };
    const guest1: Partial<User> = {
      name: "jaegeon",
    };
    const guest2: Partial<User> = {
      age: 26,
    };
    ```  
    
- 타입 별칭에서도 동일하게 사용 가능하다.  
- 코드 수를 줄일 수 있고, 유지보수에서 용이하다.  

---

### Required< **<span class="greenpen">T</span>** >

- 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성을 <span class="yellow2pen">필수 속성으로 만드는 유틸리티 타입</span>  
- 다음과 같이, 옵셔널 프로퍼티가 있는 선택 속성의 구조 존재  
- 해당 <span class="bluepen">타입을 필수로 받아야하는 별도의 구조</span> 필요 시, 사용   
- **Partial< <span class="greenpen">T</span> >**를 사용하여, 옵셔널 프로퍼티의 속성도 필수로 받는다!  
    
    ```ts   
    type User = {
      name: string;
      age?: number;
      gender: string;
    };
    
    const normalUser: User = {
      name: "jaegeon",
      gender: "male",
    };
    const adultUser: Required<User> = {
      name: "jaegeon",
      age: 26,
      gender: "male",
    };
    ```  

---

### Readonly< **<span class="greenpen">T</span>** >  

- 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성을 <span class="yellow2pen">읽기 전용으로 만드는 유틸리티 타입</span>  
- 해당 유틸리티를 사용하여, <span class="bluepen">초기값이 수정이 안되도록 막는다.</span>    
    
    ```ts   
    type User = {
      name: string;
      age?: number;
      gender: string;
    };
    
    const premiumUser: Readonly<User> = {
      name: "jaegeon",
      age: 26,
      gender: "male",
    };
    // premiumUser.name = "john"; (수정 불가)
    ```  

---

### Pick< **<span class="greenpen">T</span>**, **<span class="greenpen">K</span>** >

- **객체**로 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성에서   
  선택한 속성 **K만 추출**하여 만드는 유틸리티 타입  
- **유니언 타입 `|`** 으로 여러 개의 속성을 선택하여 추가 가능  
    
    ```ts    
    interface User {
      name: string;
      age?: number;
      gender: string;
    }
    
    const nameObj: Pick<User, "name"> = {
      name: "jaegeon",
    };
    ```  

---
    
### Omit< **<span class="greenpen">T</span>**, **<span class="greenpen">K</span>** >  
- **객체**로 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성에서    
  <span class="yellow2pen">선택한 속성 **K만 제외**하여 만드는 유틸리티 타입</span>     
- **유니언 타입 `|`** 으로 여러 개의 속성을 선택하여 제거 가능   
    
    ```ts  
    interface User {
      name: string;
      age?: number;
      gender: string;
    }
    
    const nameObj: Omit<User, "age" | "gender"> = {
      name: "jaegeon",
    };
    ```

---

### Record< **<span class="greenpen">K</span>**, **<span class="greenpen">T</span>** >

- 주어진 키 **<span class="greenpen">K</span>**와 주어진 타입 **<span class="greenpen">T</span>**을 가지는 <span class="yellow2pen">객체를 만드는 유틸리티 타입</span>   
- **`Record<string, never>`**로 **<span class="bluepen">빈 객체 생성</span>** 가능.    
    
    ```ts  
    let objEmpty: Record<string, never> = {}; // 빈 객체 생성
    const score: { math: number; english: number; science: number } = {
      math: 90,
      english: 75,
      science: 100,
    };
    const score2: Record<string, number> = {
      math: 90,
      english: 75,
      science: 100,
    };
    
    ```  

---

### Exclude< **<span class="greenpen">T</span>**, **<span class="greenpen">K</span>** >

- **유니언 타입**으로 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성에서   
  <span class="yellow2pen">선택한 속성 **K만 제외**하여 만드는 유틸리티</span>      
- **유니언 타입 `|`** 으로 여러 개의 속성을 선택하여 제거 가능  
    
    ```ts  
    type Mytype = "a" | "b" | "c";
    const res: Exclude<Mytype, "a" | "c"> = "b";
    ```  
    
---

### NonNullable< **<span class="greenpen">T</span>** >  

- 주어진 타입 **<span class="greenpen">T</span>**의 모든 속성에서   
  <span class="yellow2pen">**`null`**과 **`undefined`**를 **제외**하여 만드는 유틸리티 타입</span>  
- **유니언 타입 `|`** 으로 여러 개의 속성을 선택하여 제거 가능  
    
    ```ts  
    type Mytype = string | number | boolean | null | undefined;
    type NonType = NonNullable<Mytype>;
    ```  
    
---

### ReturnType< **<span class="greenpen">T</span>** >

- **함수**로 주어진 타입 **<span class="greenpen">T</span>**의 <span class="yellow2pen">**반환 타입**을 추출하여 만드는 유틸리티 타입</span>    
- `typeof` 키워드를 사용하여, 주어진 함수의 전체 타입을 가져온다.  
    
    ```ts   
    type Age = ReturnType<typeof getAge>; // number
    type AgeFunc = typeof getAge; // () => number
    function getAge() {
      return 20;
    }
    ```  

<div markdown="1" class="bbox"> 

#### **`typeof` 키워드 - 함수**
    
함수를 `typeof`으로 가져오면, 함수 전체의 타입을 가져온다.  
    
```ts   
type AgeFunc = typeof getAge; // () => number
function getAge() {
  return 20;
}
```   
</div>

<br>

---

## 조건부 타입

### T `extends` U ? X : Y (조건부 타입)

- **`extends`** 후위의 **U**와 비교하여, 참과 거짓에 따라 → **X, Y**의 타입이 된다.   
- 예시   
    
    ```ts   
    type IsString<T> = T extends string ? "YES" : "NO";
    type A = IsString<string>; // "YES"
    type B = IsString<number>; // "NO"
    
    const a: A = "YES";
    const b: B = "NO";
    ```   
**→ 조건부 타입**은 **제네릭**에 들어오는 타입을 제한하는 **<span class="redpen">제약 조건과는 다른 것임!</span>**    

---

### 조건부 타입 + <span class="bluepen">infer</span>  

- 제네릭이 아닌, **비교문에서의 타입을 추출**하고 싶을 때 사용   
- 예시: 적용 전  
    
    ```ts  
    type ElementType<T> = T extends any[] ? any : T;
    type A = ElementType<10>; // 10
    type B = ElementType<[10, 20, 30]>; // any
    type C = ElementType<["10", "20", "30"]>; // any
    ```
    
- 예시: 적용 후    
    
    ```ts    
    type ElementType<T> = T extends (infer U)[] ? U : T;
    type A = ElementType<10>; // 10
    type B = ElementType<[10, 20, 30]>; // 10 | 20 | 30
    type C = ElementType<["10", "20", "30"]>; // "10" | "20" | "30"
    ```  

---