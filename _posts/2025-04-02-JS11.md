---
title: "자바스크립트 복습 2"
date: 2025-04-02 18:16:37 +0900
categories: [프로그래머스 데브코스, 자바스크립트]
tags: [study, programmers, javascript]
---
## JavaScript 개념

### 스코프 scope

- 변수에 접근할 수 있는 **<span class="bluepen">유효한 범위</span>**  

### 렉시컬 스코프 lexical scope

- 코드 위치에 따라 한 실행 컨텍스트에서 **<span class="bluepen">유효한 범위</span>**  
- 작성 시점에 스코프가 결정됨.  

### 렉시컬 환경 lexical environment

- 실행 컨텍스트의 **record**와 **outer**를 아우르는 말  
    
    <img width="739" height="390" alt="Image" src="https://github.com/user-attachments/assets/d0a531a8-dd09-4f97-8bda-38f71e2846e2" />  
    
---

### eslint 세팅

- 자바스크립트의 문법적인 오류를 검사한다.  

1. eslint 패키지 설치   
    
    <img width="346" height="178" alt="Image" src="https://github.com/user-attachments/assets/93f96d43-a7dd-46ef-9a88-523f397ba21d" />  

    ```bash
    npm install eslint
    ```
    
2. eslint 초기 설정  
   eslint.config.mjs 파일 생성    
    
    <img width="638" height="121" alt="Image" src="https://github.com/user-attachments/assets/bb523159-b1d2-4a4c-840b-c07f1d9669c5" />  

    ```bash
    npm eslint --init
    ```  
    <img width="294" height="66" alt="Image" src="https://github.com/user-attachments/assets/068ebbaa-3afb-4180-b9ae-6da5e37d7159" />  
    <span class="bluepen">→ To check syntax and find problems</span>    
    
    <img width="401" height="86" alt="Image" src="https://github.com/user-attachments/assets/31b83b79-41bd-4a7b-964a-69a4e7c52160" />  
    <span class="bluepen">→ JavaScript modules</span>    
    
    <img width="384" height="105" alt="Image" src="https://github.com/user-attachments/assets/deccea96-2e9c-49fc-95c4-f27b61a94334" />   
    <span class="bluepen">→ None of these</span>    
    
    <img width="333" height="71" alt="Image" src="https://github.com/user-attachments/assets/ab2c7055-7a86-474f-9a37-0ca93b2a8847" />  
    <span class="bluepen">→ No</span>    
    
    <img width="411" height="68" alt="Image" src="https://github.com/user-attachments/assets/829556af-1b89-483c-a375-aa57d21cab67" />  
    <span class="bluepen">→ No</span>    
    
    <img width="205" height="86" alt="Image" src="https://github.com/user-attachments/assets/d1327ed5-d58a-499b-86d5-4305e11bbbd7" />  
    생성 확인!   

<br> 

---

## JavaScript 콜백, 프로미스, async await

### 콜백 함수

- 다른 함수에 **<span class="pinkpen">인수로 전달</span>**되어 나중에 호출되는 함수   
- 어떤 작업이 끝나면, 그 다음 작업을 하도록 나중에 호출됨   
  
    ```js  
    function greet(name, callback) {
      console.log("안녕하세요, " + name + "님!");
      callback();
    }
    
    function afterGreeting() {
      console.log("방문해 주셔서 감사합니다.");
    }
    
    greet("이재건", afterGreeting);
    ```    

**<span class="redpen">콜백 지옥</span>**   
- 많은 콜백함수를 중첩되어 사용하면서,  
  코드가 복잡해지고 가독성이 떨어지게 됨  

### <span class="greenpen">Promise</span>    
<img width="622" height="89" alt="Image" src="https://github.com/user-attachments/assets/b40e5bd9-0033-44e2-83ae-d6c67cce6327" />

- 자바스크립트의 <span class="greenpen">비동기 작업</span>을 처리하기 위한 객체   
- ‘나중에 결과가 올 것이다’ 약속하는 객체  
- **3가지의 PromiseState**: Pending → fullfiled, rejected 존재  
- Producer vs Consumer 관계로 설정  

---
- **`pending`**  
    - 프로미스 객체가 생성된 즉시 → 대기 중, 아직 결과가 없음  
- **`fullfilled`**  
    - 작업이 **<span class="bluepen">성공</span>**, **<span class="bluepen">resolve</span>**가 호출된 상태  
- **`rejected`**  
    - 작업이 **<span class="redpen">실패</span>**, **<span class="redpen">reject</span>**가 호출된 상태  

---
- **`then`**  
    - 성공 시, 실행할 코드  
- **`catch`**  
    - 실패 시, 실행할 코드  
- **`finally`**  
    - 작업 성공/실패 여부 상관 없이, 실행할 코드  

---
- **사용 방법**  
  **<span class="redpen">참고</span>**: 가독성을 위해, 별도로 `//` 주석 표시를 진행.  
    
    ```js
    // Promise - Producer
    const promise = new Promise((resolve, reject) => {
      const success = true;
    
      if (success) {
        resolve("실행 성공!");
      } else {
        reject("실행 실패!");
      }
    });
    
    // Promise - Consumer
    // then, catch, finally
    promise //
      .then((result) => console.log(result));
      // .then(console.log)와 동일
      .catch((error) => {
        console.log(error); 
      })
      .finally(() => {
        console.log("Promise 끝!");
      });
    ```
    
- 코드 (프로미스 2개가 then, catch, finally 처리되는 방식)  
    
    ```js
    const promise1 = new Promise((resovle, _) => {
      resovle("실행!");
      reject(new Error("에러!"));
    });
    
    const promise2 = new Promise((_, reject) => {
      reject(new Error("에러!"));
    });
    
    promise1 //
      .then((res) => {
        console.log(res);
      })
      .catch((err) => {
        console.log(err);
      })
      .finally(() => {
        console.log("마침내 끝!");
      });
    
    promise2 //
      .then((res) => {
        console.log(res);
      })
      .catch((err) => {
        console.log(err);
      })
      .finally(() => {
        console.log("마침내 끝!");
      });
    ```   
    <img width="457" height="164" alt="Image" src="https://github.com/user-attachments/assets/a8c800b3-77b8-4471-afc0-6655a0c3f770" />  
    
- **프로미스 체이닝**   
  **<span class="orangepen">then</span>**이 여러개 오면, 비동기 작업을 순차적으로 처리함.  
  **<span class="orangepen">then</span>**의 결과 값 →  `resolve`로 반환됨   
  체이닝 중간에 <span class="redpen">error 발생</span> → 후에 오는 **<span class="redpen">체이닝 중단</span>**됨!   
    
- 코드 (then을 여러개 사용 → **프로미스 체이닝**)
    
    ```js  
    const promise1 = new Promise((resovle, _) => {
      setInterval(() => {
        resovle(2);
      }, 1000);
    });
    
    promise1
      .then((res) => res * 2)
      .then((res) => res * 2)
      .then(console.log)
      .catch((err) => {
        console.log(err);
      })
      .finally(() => {
        console.log("마침내 끝!");
      });
    ```  
    
    <img width="337" height="62" alt="Image" src="https://github.com/user-attachments/assets/ffe30802-e5ba-41c0-a3ac-60990bf697f0" />
    
- 코드 (**프로미스 <span class="redpen">체이닝 중단</span>**)
    
    ```js  
    const promise1 = new Promise((resovle, _) => {
      setInterval(() => {
        resovle(2);
      }, 1000);
    });
    
    promise1
      .then((res) => {
        return new Promise((_, reject) => {
          reject(new Error(res * 2));
        });
      })
      .then((res) => res * 2)
      .then(console.log)
      .catch((err) => {
        console.log(err);
      })
      .finally(() => {
        console.log("마침내 끝!");
      });  
    ```  

    <img width="321" height="116" alt="Image" src="https://github.com/user-attachments/assets/1f06a766-0bb4-4645-93e3-2a71c87879a6" />  
    
- 코드 (**프로미스 체이닝 중단 방지**)   
  에러를 중간에 잡음!  
    
    ```js
    const promise1 = new Promise((resovle, _) => {
      setInterval(() => {
        resovle(2);
      }, 1000);
    });
    
    promise1 //
      .then((res) => {
        return new Promise((_, reject) => {
          reject(new Error(res * 2));
        });
      })
      .catch(() => 1)
      .then((res) => {
        return new Promise((_, reject) => {
          reject(new Error(res * 2));
        });
      })
      .catch(() => 1)
      .then(console.log)
      .catch((err) => console.log(err));
    ```  
    
    <img width="178" height="77" alt="Image" src="https://github.com/user-attachments/assets/3bad8157-84f4-4904-aa66-58b97cf73466" />  
    
### 콜백함수 → <span class="greenpen">Promise</span>  

- **<span class="redpen">콜백지옥</span>**에 빠진 함수를 **<span class="greenpen">Promise 생성식</span>**으로 바꿔보자.    
- 코드  
    ```js
    function task1() {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log("task1");
          resolve();
        }, 1000);
      });
    }
    function task2() {
      return new Promise((resolve) => {
        console.log("task2");
        resolve();
      });
    }
    function task3() {
      return new Promise((resolve) => {
        console.log("task3");
        resolve();
      });
    }
    function task4() {
      return new Promise((resolve) => {
        console.log("task4");
        resolve();
      });
    }
    
    task1() 
      .then(() => task2())
      .then(() => task3())
      .then(() => task4());
    ```  
    
    <img width="464" height="119" alt="Image" src="https://github.com/user-attachments/assets/9186c964-429b-468e-90b1-1fba154465cb" />  
    
### <span class="bluepen">async</span> 문법  

- **Sugar Syntax(설탕 문법)**의 예시 중 하나이다.  
    - 기존 기능을 더 쉽게, 짧게 쓸 수 있게 해주는 문법  
- 기존의 형태  
    
    ```js
    function promise() {
       return new Promise((resolve) => {
          resolve("작업 성공");
       });
    }
    ```
    
- **<span class="bluepen">async</span>** 사용!   
  `resolve`가 감싸진 **<span class="greenpen">Promise 객체</span>**가 리턴됨   
    
    ```js
    async function promise() {
      return "작업 성공";
    }
    ```  
    - 코드 (예시)
        
        ```js
        async function getBall1() {
          return "⚽"; // resolve가 감싸진 Promise 객체가 리턴됨
          //   return new Promise((resolve) => {
          //     resolve("⚽");
          //   });
        }
        
        getBall1() //
          .then(console.log);
        
        async function getBall2() {
          return "⚾";
        }
        
        getBall2() //
          .then(console.log);
        
        ```  
        

### <span class="bluepen">async</span> & <span class="bluepen">await</span> 문법  

- 기존의 형태  
    
    ```js
    function 처리함수() {
      getHen() //
        .then((hen) => {
          getEgg() //
            .then((egg) => {
              console.log(`${hen} + ${egg} = 🍳`);
            });
        });
    }
    처리함수();
    ```  
    
- **<span class="bluepen">async</span> & <span class="bluepen">await</span>** 사용!   
  **<span class="greenpen">Promise</span>**의 **<span class="redpen">콜백 지옥</span>**에서 벗어날 수 있음  
    
    ```js
    async function 처리함수() {
      const hen = await getHen();
      const egg = await getEgg(); 
      console.log(`${hen} + ${egg} = 🍳`);
    }
    처리함수();
    ```  
    
    - 코드 (예시)
        
        ```js
        // Sugar Syntax (설탕 문법)
        async function getHen() {
          return "🐓"; // resolve 감싸진 Promise 객체가 리턴됨
          // return new Promise((resolve) => {
          //   resolve("🐓");
          // });
        }
        
        getHen() //
          .then((hen) => console.log(hen));
        
        async function getEgg() {
          return "🥚";
        }
        
        getEgg() //
          .then((egg) => console.log(egg));
        
        // await
        function makeMeal() {
          getHen() //
            .then((hen) => {
              getEgg() //
                .then((egg) => {
                  console.log(`${hen} + ${egg} = 🍳`);
                });
            });
        }
        
        makeMeal();
        
        // await ! 기다려!
        async function makeMeal2() {
          const hen = await getHen();
          const egg = await getEgg(); //
          console.log(`${hen} + ${egg} = 🍳`);
        }
        
        makeMeal2();
        ```  

### 콜백함수 → <span class="bluepen">async</span> & <span class="bluepen">await</span>  

- **<span class="redpen">콜백지옥</span>**에 빠진 함수를 **<span class="bluepen">async</span> & <span class="bluepen">await</span>** 형식으로 바꿔보자.  
- 코드  
    
    ```js
    async function task1() {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log("task1");
          resolve();
        }, 1000);
      });
    }
    async function task2() {
      return new Promise((resolve) => {
        console.log("task2");
        resolve();
      });
    }
    async function task3() {
      return new Promise((resolve) => {
        console.log("task3");
        resolve();
      });
    }
    async function task4() {
      return new Promise((resolve) => {
        console.log("task4");
        resolve();
      });
    }
    
    async function runTask() {
      await task1();
      await task2();
      await task3();
      await task4();
    }
    ```   
    <img width="458" height="119" alt="Image" src="https://github.com/user-attachments/assets/8e397055-2de1-4daa-a824-a2dcb2d8cc6d" />  

---