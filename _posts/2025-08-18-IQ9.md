---
title: "클로저(Closure)란?"
date: 2025-08-18 12:34:56 +0900
categories: [CS, CS-프론트엔드]
tags: [study, cs, frontend]
---

<img width="1271" height="713" alt="면접fe" src="https://github.com/user-attachments/assets/62dd472e-ea9e-49ab-97c0-dc6919de6fba" />

## **클로저(Closure)란?**   
**클로저(Closure)**는 함수가 <span class="bluepen">자신이 선언될 때의 실행 컨텍스트의 스코프를 기억</span>하는 기능이다.    
따라서, 함수가 스코프 밖에서 실행될 때도 그 스코프에 접근할 수 있다.  
관련 용어를 자세히 알아보자.  

<br>

---

### **렉시컬 스코프(Lexical Scope)**  

`스코프`는 변수에 접근할 수 있는 유효한 범위를 말하는데,  
여기서 **렉시컬 스코프**는 코드 위치에 따라 <span class="bluepen">하나의 실행 컨텍스트에서 유효한 범위</span>를 지칭한다.  

이 때, 이 범위는 어디서 호출한 것이 아니라,   
<span class="yellow2pen">어디서 **선언(작성)**했는지에 따라 결정</span>된다.

<br>

---

### **가비지 컬렉터(GarbageCollector)**  

**가비지 컬렉터**는 가비지 컬렉션이라는 과정을 담당한다.  
`가비지 컬렉션`은 메모리에 할당된 값이 필요없을 때, 메모리를 해제시키는 과정을 말하며.  
이 때, 필요없다는 기준은 <span class="redpen">root에서 닿을 수 있는 객체들이 아닌 경우</span>가 된다.  

<br>

---

### 클로저 예시

다음과 같은 코드가 **클로저**에서 사용되는 예시이다.   
해당 특징으로 인해, <span class="yellow2pen">함수가 반환되어 종료되어도 해당 변수를 계속 사용</span>할 수 있다.  

```js
function makeCounter() {
  let count = 0;
  return function () {
    count += 1;
    return count;
  }
}

var func = makeCounter();
func(); 
```  
해당 코드를 확인해보면, 
**GarbageCollector**가 `makeCounter()`의 참조를 없앨 것으로 예상되나,    
`내부 함수`가 해당 스코프의 변수인 count를 참조하고 있어서 없어지지 않는다.    
  
따라서 스코프 외부에서 `내부 함수`가 실행되도 해당 스코프를 기억하므로,  
해당 변수를 계속 사용 가능한 것이다.  

<img width="1262" height="579" alt="Image" src="https://github.com/user-attachments/assets/d0f7a983-5bf1-4195-9c7d-095acbaeb90d" />   

<img width="1265" height="555" alt="Image" src="https://github.com/user-attachments/assets/59d3c310-e8ae-4dca-88dd-208a37ba520b" />  

따라서, 자바스크립트에는 없는 캡슐화라는 개념을 구현할 수 있고     
<span class="bluepen">정보 은닉</span>과 <span class="bluepen">캡슐화</span>의 이점을 활용할 수 있다.  

<br>

---

##### ✨ 출처

[blog, 프론트엔드 면접 문제 은행](https://velog.io/@wkahd01/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EB%AC%B8%EC%A0%9C-%EC%9D%80%ED%96%89-HTML-%EC%A7%88%EB%AC%B8-%EB%8B%B5%EB%B3%80)     
{: .small}   

---